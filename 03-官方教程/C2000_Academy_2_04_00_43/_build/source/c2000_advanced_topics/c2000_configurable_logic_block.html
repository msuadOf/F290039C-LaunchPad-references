
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Configurable Logic Block (CLB) &#8212; C2000 Academy  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/local/font.css" />
    <link rel="stylesheet" type="text/css" href="https://www.ti.com/assets/fonts/font.css" />
    <link rel="stylesheet" type="text/css" href="https://www.ti.com/assets/style/resource-explorer.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/design-tabs.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/quizdown.js"></script>
    <script>quizdown.init({"quizdown_js": "quizdown.js", "start_on_load": true, "shuffle_answers": false, "shuffle_questions": false, "primary_color": "var(--pst-color-primary)", "secondary_color": "#DDDDDD", "text_color": "black"});</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'source/c2000_advanced_topics/c2000_configurable_logic_block';</script>
    <script src="../../_static/quizdown.js"></script>
    <link rel="canonical" href="http://127.0.0.1:8000/source/c2000_advanced_topics/c2000_configurable_logic_block.html" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Interprocessor Communications (IPC)" href="c2000_interprocessor_communications.html" />
    <link rel="prev" title="Direct Memory Access (DMA)" href="c2000_direct_memory_access.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search C2000 Academy" aria-label="Search C2000 Academy" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    

    
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article"></div>
              
              
                <article class="bd-article" role="main">
                  
                  
<div id="searchbox"></div>
                  
  <section class="tex2jax_ignore mathjax_ignore" id="configurable-logic-block-clb">
<h1>Configurable Logic Block (CLB)<a class="headerlink" href="#configurable-logic-block-clb" title="Permalink to this heading">#</a></h1>
<p>The Configurable Logic Block (CLB) is a peripheral exclusive to C2000 devices
that allows users to incorporate custom logic without the need for an external
logic device such as an FPGA or CLPD. The CLB peripheral itself is made up of a
number of tiles, each composed of various submodules that combine together to
enable the implementation of custom digital logic functions. The CLB can also
be connected to other existing control peripherals on the device to enhance
their functionality and provide even more design options.</p>
<p><img alt="CLB Peripheral" src="../../_images/clb_periph.png" /></p>
<p>Currently, there are three different versions of the CLB peripheral. Each
incremental version of the peripheral offers additional features on top of all
capabilities of previous versions. For information about the differences
between the CLB types, refer to the Configurable Logic Block (CLB) Module
section of the <a class="reference external" href="https://ti.com/lit/SPRU566">C2000 Peripherals Guide</a>.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>CLB Type</p></th>
<th class="head"><p>Devices</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>1</p></td>
<td><p>F28x7x, F2837xS, F2837xD</p></td>
</tr>
<tr class="row-odd"><td><p>2</p></td>
<td><p>F28004x</p></td>
</tr>
<tr class="row-even"><td><p>3</p></td>
<td><p>F28002x, F28003x, F2838x</p></td>
</tr>
</tbody>
</table>
<section id="applications-of-clb">
<h2>Applications of CLB<a class="headerlink" href="#applications-of-clb" title="Permalink to this heading">#</a></h2>
<p>The CLB is a powerful tool that can be used in a variety of applications. The
CLB can be used as a replacement for external custom logic devices, resulting
in reduced system cost and reduced board area. Because the CLB is built
directly into the C2000 device, it has direct access to other on-chip
peripherals, resulting in reduced feedback latency and improved control loop
times. In addition, the CLB has an additional advantage over external logic
devices in that all timing requirements between the CLB and CPU are
automatically met.</p>
<p>Given the customizability of the CLB, there are many possible applications of
this peripheral. The <a class="reference external" href="https://www.ti.com/tool/C2000WARE">C2000Ware SDK</a>
provides a variety of simple cases as well as more comprehensive
implementations using the CLB. Specific examples of applications of the CLB
include the following:</p>
<ul class="simple">
<li><p>Customized General Purpose Outputs (CLB example 1)</p></li>
<li><p>Signal Conditioning and Intelligent Filtering (CLB example 2)</p></li>
<li><p>Complex PWM generation (CLB example 3)</p></li>
<li><p>Advanced PWM Protection and Dead-Band Compensation (CLB example 4)</p></li>
<li><p>Task Profiling and Time Threshold Monitoring (CLB example 5)</p></li>
<li><p>Complex Signal Capture and Sequence Detection (CLB example 6)</p></li>
</ul>
<p>Additionally, the <a class="reference external" href="https://www.ti.com/tool/C2000WARE-MOTORCONTROL-SDK">MotorControl SDK</a>
showcases use of the CLB in pulse-train output (PTO) applications as well as
position sensing and absolute encoder interfaces. The CLB is not limited to
these specific applications, and there are many more use cases that the CLB can
be purposed in.</p>
</section>
<section id="clb-tile-architecture">
<h2>CLB Tile Architecture<a class="headerlink" href="#clb-tile-architecture" title="Permalink to this heading">#</a></h2>
<p>The Configurable Logic Block peripheral is made up of a number of individual
CLB “tiles”. A tile is essentially a collection of logic blocks which
interconnect to perform different logical operations. Depending on the device,
the number of tiles can range from 2 tiles up to 8 tiles. Each individual CLB
tile has 8 inputs and 8 outputs. These external connections are known as the
CLB tile’s BOUNDARY connections (BOUNDARY_INx and BOUNDARY_OUTx). Outputs of
one tile can serve as inputs into another, further expanding the possible
functionality of the CLB peripheral. The following table describes the number
of CLB tiles in the current generation of C2000 devices.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>No. of CLB Tiles</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F28002x</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>F28x7x, F2837xS, F2837xD</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>F28003x</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>F28004x</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>F2838x</p></td>
<td><p>8</p></td>
</tr>
</tbody>
</table>
<p>[[y! CLB Peripheral is Package-Dependent
The CLB peripheral is included only in specific device packages. Refer to the
Device Comparison table within the specific device family’s datasheet to verify
the number of CLB tiles in the device package.</p>
<p>Each tile is composed of a number of configurable blocks (submodules) that
serve specific functions and can be used together. The types and quantity of
submodules in each CLB tile are as follows:</p>
<ul class="simple">
<li><p>Three 4-input Lookup Tables (LUT4)</p></li>
<li><p>Three Finite State Machines (FSM)</p></li>
<li><p>Three Counters</p></li>
<li><p>Eight Output 3-input Lookup Tables (OUTLUT)</p></li>
<li><p>One High-Level Controller (HLC)</p></li>
<li><p>Eight Asynchronous Output Conditioning (AOC) blocks</p></li>
</ul>
<p><img alt="CLB Tile" src="../../_images/clb_tile_submodules.png" /></p>
<p>Inputs into each submodule can be the following:</p>
<ul class="simple">
<li><p>CLB Boundary inputs</p></li>
<li><p>outputs from LUT4 blocks</p></li>
<li><p>outputs or states from FSM blocks</p></li>
<li><p>match conditions from Counter blocks</p></li>
</ul>
<section id="input-lookup-table">
<h3>4-Input Lookup Table<a class="headerlink" href="#input-lookup-table" title="Permalink to this heading">#</a></h3>
<p>The <strong>4-Input Lookup Table (LUT4)</strong> submodule allows for the realization of any
combinatorial boolean equation of up to 4 inputs. It is composed of 4 inputs
(IN0, IN1, IN2, and IN3) and a 16-bit function register that defines the output
of the LUT4 block.</p>
<p><img alt="LUT4 Submodule" src="../../_images/lut4_ss.png" /></p>
</section>
<section id="finite-state-machine">
<h3>Finite State Machine<a class="headerlink" href="#finite-state-machine" title="Permalink to this heading">#</a></h3>
<p>The <strong>Finite State Machine (FSM)</strong> submodule can be used as a 4-state finite
state machine or as two independent 2-state finite state machines. The finite
state machine submodule can take in two external inputs as well as two extra
external inputs. The FSM can generate two state outputs and one combinatorial
output.</p>
<p>The FSM submodule is useful for implementing more complex logic than is
possible on a simple look-up table. For example, if an application has a single
input trigger but requires a system to perform a different operation based on
the state of the system and the previous inputs that were received, an FSM can
be used. Similarly, an FSM can be used to implement an end state which halts
the system from registering any inputs when an end state is reached.</p>
<p>Inputs into the FSM submodule include two external inputs (EXT IN0 and EXT IN1).
The submodule includes two 16-bit equation registers which define the states
(S0 and S1) of the finite-state machine. An additional 16-bit equation register
is available which defines the output of the FSM submodule.</p>
<p>If any FSM submodules have unused state bits, those submodules can instead be
used as additional 3-input or 4-input LUTs. In this implementation, one or both
of the extra external inputs (EXTRA EXT IN0 and EXTRA EXT IN1) override S0 and
S1, respectively, and function as inputs for the 3-input or 4-input LUT.</p>
<p><img alt="FSM Submodule" src="../../_images/fsm_ss.png" /></p>
</section>
<section id="counter">
<h3>Counter<a class="headerlink" href="#counter" title="Permalink to this heading">#</a></h3>
<p>The 32-bit <strong>Counter</strong> submodule can be configured either as an adder, a
counter, or a shifter. As an adder, it can continually add or subtract a
desired value. In counter mode, it can increment or decrement. Finally, as a
shifter, it can shift left or shift right.</p>
<p>The RESET input of the counter submodule is the highest priority input, and
when it is brought high, the value of the counter is reset to 0. The MODE 0
input acts as the enable for the counter, and the counter only counts when MODE
0 is high. The MODE 1 input determines the direction that the counter submodule
counts in (when MODE 0 is high). If MODE 1 is low, the counter is set to
decrement, and when MODE 1 is high, the counter is set to increment.</p>
<p>Each counter submodule has up to three match conditions: one zero match and two
configurable nonzero matches (match1 and match2). These match conditions can be
used as trigger signals for other submodules within the same tile. The counter
submodule also has an event input which can trigger the counter to add,
subtract, shift left, shift right, or load a specific value upon an event
trigger.</p>
<p><img alt="Counter Submodule" src="../../_images/counter_ss.png" /></p>
<p>Two of the 32-bit Counter submodules can be combined together in a cascaded
counter implementation to emulate a 64-bit counter. This extends the maximum
effective counting limit from the 32-bit unsigned maximum of 4,294,967,295 to
the 64-bit unsigned maximum of 18,446,744,073,709,551,615. Since a single tile
contains only three Counter modules, the resulting effective counters are one
64-bit counter and one 32-bit counter. Three counters can be cascaded together
to result in a 96-bit counter, if desired.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Cascaded Counter Configuration<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">To create the 64-bit cascaded counter within the CLB tile, two counters (in
this configuration, COUNTER_0 and COUNTER_1) should be configured as follows:</p>
<p class="sd-card-text"><img alt="Cascade Counter 0" src="../../_images/cascade_counter0.png" /></p>
<p class="sd-card-text">The primary counter is configured with a match1 value of 4,294,967,295 (maximum
value of a 32-bit unsigned integer) and resets back to zero when the count
reaches this match1 value. MODE0 and MODE1 are set to 1 so that the counter
always increments, although the MODE0 enable bit can be set to another trigger
condition depending on the implementation of the CLB.</p>
<p class="sd-card-text"><img alt="Cascade Counter 1" src="../../_images/cascade_counter1.png" /></p>
<p class="sd-card-text">The secondary counter is configured as the overflow counter. Like the primary
counter, it is configured with a match1 value of 4,294,967,295 and resets to
zero when the counter reaches this maximum. MODE0 of this counter is configured
as the match1 condition of the primary counter. This is so that the secondary
counter only increments when the primary counter overflows. MODE1 is set to 1
to indicate the direction of count as positive. With this, the effective
counting limit of COUNTER_0 and COUNTER_1 combined is the 64-bit unsigned
integer maximum.</p>
<p class="sd-card-text">A similar implementation can be used to achieve a 96-bit counter, if desired.</p>
</div>
</details><p>On devices with CLB type 2 and later, the Counter has the ability to function
as a 32-bit shift register (serializer). In serializer mode, the various
Counter submodule configuration options are repurposed to shift data into and
out of the serializer. The event input will be used to shift data into the
serializer bit-by-bit and the two nonzero match conditions will used to trigger
the tapping (shifting out) of the serial bits. The exact bit that gets tapped
upon the match triggers can be configured using the corresponding match tap
selection parameter.</p>
<p>In addition, CLB type 2 and later have the ability to operate the Counter as a
linear feedback shift register (LFSR). The Counter is thus able to calculate
the cyclic redundance check (CRC) value on a serial bit stream.</p>
<p>On devices with CLB type 3 and later, the Counter module can be configured to
operate in pipeline mode. Pipelining enables the Counter’s event-triggered add/
sub/shift operations to use the value of the Counter in the previous cycle.</p>
<p>Examples showcasing these extended features of the counter submodule are
available within the C2000Ware SDK.</p>
</section>
<section id="output-3-input-lookup-table">
<h3>Output 3-Input Lookup Table<a class="headerlink" href="#output-3-input-lookup-table" title="Permalink to this heading">#</a></h3>
<p>The <strong>Output 3-Input Lookup Table (OUTLUT)</strong> submodule allows for the
realization of any combinatorial boolean equation of up to 3 inputs. These
eight OUTLUT submodules correspond to the output BOUNDARY of the CLB tile. The
data described in this submodule can be routed to other CLB tiles or outside of
the CLB using the device’s crossbars.</p>
<p>Note: OUTLUT outputs <strong>cannot</strong> be used to drive the inputs on other submodule
blocks within the same tile.</p>
<p><img alt="Output LUT Submodule" src="../../_images/output-lut_ss.png" /></p>
</section>
<section id="high-level-controller">
<h3>High-Level Controller<a class="headerlink" href="#high-level-controller" title="Permalink to this heading">#</a></h3>
<p>The <strong>High-Level Controller (HLC)</strong> submodule is a powerful, event-driven block
which can used to exchange data between the CLB and CPU and to issue
interrupts. The HLC can have up to four concurrent events, each capable of
realizing a specific set of instructions upon an event trigger. The lowest
numbered event (Event 0) has the highest priority, and the highest numbered
event (Event 3) has the lowest priority. There are also four registers that can
be used to exchange data and modify/initialize values for the counter blocks.</p>
<p><img alt="HLC Submodule" src="../../_images/hlc_ss.png" /></p>
<p>Each HLC event is composed of up to 8 instructions and has a trigger condition
that signals when to execute the program. On devices with CLB type 2 or later,
both the rising and falling edges of a signal can be used as the event trigger
condition. On devices with CLB type 3 or later, the HLC has a pipeline mode
which allows the HLC to access CLB TILE outputs delayed by one cycle.</p>
<p>All possible HLC instructions are listed in the table below. Note that R0, R1,
R2, and R3 refer to the four registers located within the HLC. C0, C1, and C2
refer to the three counters located within the CLB tile.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Instruction</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>ADD &lt;Src&gt; &lt;Dest&gt;</p></td>
<td><p>This instruction performs a 32-bit unsigned addition, where &lt;Dest&gt; = &lt;Dest&gt; + &lt;Src&gt;. <br/> The &lt;Src&gt; can be R0, R1, R2, R3, C0, C1, or C2. The &lt;Dest&gt; can only be R0 or R3.</p></td>
</tr>
<tr class="row-odd"><td><p>INTR &lt;6-bit constant&gt;</p></td>
<td><p>This instruction will flag an interrupt through the CPU interface. <br/> The 6-bit constant is stored in the interrupt flag register CLB_INTR_TAG_REG.</p></td>
</tr>
<tr class="row-even"><td><p>MOV &lt;Src&gt; &lt;Dest&gt;</p></td>
<td><p>This instruction moves &lt;Src&gt; to &lt;Dest&gt;. <br/> Both &lt;Src&gt; and &lt;Dest&gt; can be any of R0, R1, R2, R3, C0, C1, or C2.</p></td>
</tr>
<tr class="row-odd"><td><p>MOV_T1 &lt;Src&gt; &lt;Dest&gt;</p></td>
<td><p>This instruction moves &lt;Src&gt; to the Match1 register of the &lt;Dest&gt; counter. <br/> &lt;Src&gt; can be any of the registers R0, R1, R2, R3, or the counter values associated with C0, C1, or C2. <br/> &lt;Dest&gt; is the Match1 register of any of the counters C0, C1, or C2.</p></td>
</tr>
<tr class="row-even"><td><p>MOV_T2 &lt;Src&gt; &lt;Dest&gt;</p></td>
<td><p>This instruction moves &lt;Src&gt; to the Match2 register of the &lt;Dest&gt; counter. <br/> &lt;Src&gt; can be any of the registers R0, R1, R2, R3, or the counter values associated with C0, C1, or C2. <br/> &lt;Dest&gt; is the Match2 register of any of the counters C0, C1, or C2.</p></td>
</tr>
<tr class="row-odd"><td><p>PULL &lt;Dest&gt;</p></td>
<td><p>This instruction transfers data from the data exchange pull memory buffer <br/> in the CPU interface to the &lt;Dest&gt; register. <br/> &lt;Dest&gt; can be any of R0, R1, R2, R3, C0, C1, or C2.</p></td>
</tr>
<tr class="row-even"><td><p>PUSH &lt;Src&gt;</p></td>
<td><p>This instruction transfers data from &lt;Src&gt; to the data exchange push memory buffer <br/> in the CPU interface. <br/> &lt;Src&gt; can be any of R0, R1, R2, R3, C0, C1, or C2.</p></td>
</tr>
<tr class="row-odd"><td><p>SUB &lt;Src&gt; &lt;Dest&gt;</p></td>
<td><p>This instruction performs a 32-bit unsigned subtraction, where &lt;Dest&gt; = &lt;Dest&gt; - &lt;Src&gt;. <br/> The &lt;Src&gt; can be R0, R1, R2, R3, C0, C1, or C2. The &lt;Dest&gt; can only be R0 or R3.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="asynchronous-output-conditioning-block">
<h3>Asynchronous Output Conditioning Block<a class="headerlink" href="#asynchronous-output-conditioning-block" title="Permalink to this heading">#</a></h3>
<div class="admonition-aoc-only-on-clb-type-2-and-above admonition">
<p class="admonition-title">AOC Only on CLB Type 2 and Above</p>
<p>The output conditioning block is available only on device families with CLB
Type 2 or later.</p>
</div>
<p>The <strong>Asynchronous Output Conditioning (AOC) Block</strong> submodule enables the
filtering and modification of signals going into or coming out of the CLB.
There are 8 inputs into the AOC Block. When configuring inputs into the AOC
Block, either the respective BOUNDARY input or the respective BOUNDARY output
can be selected. The signals pass through three different stages which are each
responsible for performing a specific type of logic modification. The output of
this AOC block is the modified version of the input which has undergone
inverting, gating, release control, or some combination of the three.</p>
<p>-<strong>Stage 1 (Inverting)</strong>: This stage allows for the input signal to be
inverted.</p>
<p>-<strong>Stage 2 (Gating)</strong>: This stage allows for the input signal to be gated
(AND, OR, or XOR) with a gating control signal. This control signal can come
from any of the CLB tile’s BOUNDARY outputs or from a software register.</p>
<p>-<strong>Stage 3 (Release Control)</strong>: This stage allows for the input signal to be
set or cleared with a gating control signal. Similarly to the gating stage,
this control signal can be one of the CLB tile’s outputs or a software
register.</p>
<p>For each of the stages, there is a bypass option which passes the signal
unmodified to the next stage.</p>
</section>
</section>
<section id="clb-connections">
<h2>CLB Connections<a class="headerlink" href="#clb-connections" title="Permalink to this heading">#</a></h2>
<p>Connections into and out of the CLB are divided into three different buses.</p>
<ul class="simple">
<li><p>The <strong>local input bus</strong> allows for dedicated connection to specific instances
of ePWM, eQEP, and eCAP.</p></li>
<li><p>The <strong>global input bus</strong> is connected to other system peripherals and
crossbars.</p></li>
<li><p>The <strong>output bus</strong> connects the outputs of the CLB to other peripherals on
the device. It includes a set of external multiplexers that can be used to
override the output of other peripherals.</p></li>
</ul>
<section id="clb-tile-input-buses">
<h3>CLB Tile Input Buses<a class="headerlink" href="#clb-tile-input-buses" title="Permalink to this heading">#</a></h3>
<p>The local and global input buses allow for a wide variety of signals to be
passed into the CLB.</p>
<p>The <strong>local input bus</strong> is primarily used to bring signals from the device’s
control peripherals (ePWM, eQEP, eCAP) into the CLB. These include signals such
as digital compare events and trip zones from ePWM, pulse signals from eQEP,
and capture events from eCAP. In addition, on devices with CLB type 3 or later,
input signals coming through the CLB Input X-BAR can be brought into the CLB
using the local input bus.</p>
<p>The <strong>global input bus</strong> is used to bring in signals from other system
peripherals. The CLB global input bus can be configured to accept CLB X-BAR
auxiliary signals (AUXSIG), outputs from other CLB tiles, and various signals
from ePWM, ERAD, FSI, and SPI. The MUX selection configuration for CLB inputs
is shown in the following figure.</p>
<p><img alt="CLB Input Mux" src="../../_images/clb_input_mux.png" /></p>
<div class="admonition-important-clb-input-consideration admonition">
<p class="admonition-title">Important CLB Input Consideration</p>
<p>On the local input bus, CLB tiles are only configured to accept inputs from
specific instances of other peripherals. For example, CLB1 can accept inputs
from EPWM1, EQEP1, and ECAP1. Inputs from other instances of these peripherals,
e.g. EPWM3 or EQEP2, cannot be used as inputs into CLB1. Likewise, CLB2 can
accept inputs from only the second instance of these control peripherals, i.e.
EPWM2, EQEP2, and ECAP2. This does not apply to signals that are brought in
with the global input bus. Global input bus signals can be routed to any CLB
tile on the device. Refer to the device’s TRM for details regarding
specific peripheral inputs.</p>
</div>
</section>
<section id="clb-tile-input-filtering-and-synchronization">
<h3>CLB Tile Input Filtering and Synchronization<a class="headerlink" href="#clb-tile-input-filtering-and-synchronization" title="Permalink to this heading">#</a></h3>
<p>Inputs into the CLB can be further augmented using the CPU. The Input Select
block of the CPU has input latching and filtering capabilities allowing for
input filtering, rising-edge detection, falling-edge detection, and input
synchronization. Furthermore, depending on the signal being passed to the CLB
inputs, it may be necessary to enable the CLB input synchronizer to ensure that
the input signal aligns with the CLB clock and its logic.</p>
<div class="admonition-async-input-signals admonition">
<p class="admonition-title">ASYNC Input Signals</p>
<p>Some peripheral and device signals are naturally asynchronous. For these input
signals, it is <strong>mandatory</strong> to enable CLB input synchronization. Failure to do
so may result in metastability hazards within the logic of the CLB. This
metastability can cause errors depending on the voltage, temperature, and wafer
fab process. Do note that this requirement is in addition to and separate from
the GPIO input synchronization. Refer to the device TRM for a comprehensive
list of these ASYNC signals.</p>
</div>
</section>
<section id="clb-tile-software-triggering">
<h3>CLB Tile Software Triggering<a class="headerlink" href="#clb-tile-software-triggering" title="Permalink to this heading">#</a></h3>
<p>The GPREG register is a CPU-accessible register within each CLB tile that
connects to the BOUNDARY inputs of the tile. The eight bits of the GPREG
register correspond to the eight inputs of the CLB tile, and they can be
individually set to enable or disable their respective BOUNDARY inputs using
the<code class="docutils literal notranslate"><span class="pre">CLB_setGPREG()</span></code> function. For example, the following code clears the
GPREG register of CLB TILE1 then enables BOUNDARY_IN0 and BOUNDARY_IN1.</p>
<p><code class="docutils literal notranslate"><span class="pre">CLB_setGPREG(CLB1_BASE,</span> <span class="pre">0);</span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <span class="pre">//</span> <span class="pre">GPREG:</span> <span class="pre">0b00000000</span> <span class="pre">CLB_setGPREG(CLB1_BASE,</span> <span class="pre">1</span> <span class="pre">&amp;lt;&amp;lt;</span> <span class="pre">0</span> <span class="pre">|</span> <span class="pre">1</span> <span class="pre">&amp;lt;&amp;lt;</span> <span class="pre">1);</span>&#160;&#160; <span class="pre">//</span> <span class="pre">GPREG:</span> <span class="pre">0b00000011</span></code></p>
</section>
<section id="clb-tile-gpio-inputs">
<h3>CLB Tile GPIO Inputs<a class="headerlink" href="#clb-tile-gpio-inputs" title="Permalink to this heading">#</a></h3>
<p>GPIOs can be routed into the CLB using a combination of the GPIO Input X-BAR
and CLB X-BAR. With this, the GPIO becomes routed as an auxiliary signal
(AUXSIG) through the global input bus.</p>
<ul class="simple">
<li><p>First, the GPIO is routed through the GPIO input crossbar and assigned to one
of the instances of Input X-BAR.</p></li>
<li><p>Afterwards, the chosen instance of Input X-BAR is connected to the CLB X-BAR.</p></li>
<li><p>The corresponding mux of the CLB X-BAR must be configured to route the GPIO
signal to an AUXSIG.</p></li>
<li><p>The chosen AUXSIG input can then be configured as an input from the global
signal bus.</p></li>
</ul>
<p><img alt="CLB GPIO Input Method 1" src="../../_images/clb_gpio_input1_alt.png" /></p>
<p>On devices with CLB type 3 or later, an alternate method can be used. On these
devices, the CLB includes a dedicated CLB input crossbar (known as CLB INPUT
X-BAR) which can directly route GPIO signals as inputs into the CLB. The
desired GPIO signal is chosen through the CLB INPUT X-BAR and routed to the CLB
through the local input bus.</p>
<p><img alt="CLB GPIO Input Method 2" src="../../_images/clb_gpio_input2_alt.png" /></p>
</section>
<section id="clb-tile-output-replication">
<h3>CLB Tile Output Replication<a class="headerlink" href="#clb-tile-output-replication" title="Permalink to this heading">#</a></h3>
<p>Each of the eight outputs in a tile are replicated multiple times to be used as
different output signals. For devices with CLB Type 1, each output is
replicated twice to create 16 separate output signals. For example, output 0
(corresponding to OUTLUT0) corresponds to CLBx_OUT0 and CLBx_OUT8. Starting
with CLB Type 2, these output signals are replicated four times for a total of
32 output signals. On these iterations of CLB, output 0 of CLBx corresponds to
the following output signals: CLBx_OUT0, CLBx_OUT8, CLBx_OUT16, and CLBx_OUT24.</p>
<p><img alt="CLB Output Replication" src="../../_images/clb_outputs.png" /></p>
</section>
<section id="clb-tile-peripheral-signal-overriding">
<h3>CLB Tile Peripheral Signal Overriding<a class="headerlink" href="#clb-tile-peripheral-signal-overriding" title="Permalink to this heading">#</a></h3>
<p>Each of the CLB outputs is fed into the Peripheral Signal Mux and has a
separate enable bit defined in the CLB Output enable register, CLB_OUT_EN.
Enabling this bit will force the CLB output to override the peripheral signal
corresponding to that output. Specific peripheral signal information can be
found in the device’s TRM.</p>
<p><img alt="CLB Output Peripheral Signal Mux" src="../../_images/clb_periph_mux.png" /></p>
</section>
<section id="clb-tile-gpio-outputs">
<h3>CLB Tile GPIO Outputs<a class="headerlink" href="#clb-tile-gpio-outputs" title="Permalink to this heading">#</a></h3>
<p>The CLB can output signals directly to the GPIOs of the C2000 device. To output
the CLB signal to the GPIO pins, the GPIO Output X-BAR must be configured to
route the CLB tile output to an instance of Output X-BAR. The GPIO Output X-Bar
is only connected to outputs 4 and 5 of each CLB tile, and the specific mux
corresponding to the desired CLB output must be chosen.</p>
<p><img alt="CLB GPIO Output Method 1" src="../../_images/clb_gpio_output1_alt.png" /></p>
<p>On devices with CLB type 3 or later, the CLB has a dedicated CLB output
crossbar (known as CLB OUTPUT X-BAR). Each CLB tile output has a dedicated mux
in the CLB output crossbar. This mux can be configured to an instance of a CLB
Output X-Bar which brings the signal to a GPIO. With this approach, any of the
outputs of the CLB can be driven to a GPIO.</p>
<p><img alt="CLB GPIO Output Method 2" src="../../_images/clb_gpio_output2_alt.png" /></p>
</section>
<section id="connecting-multiple-clb-tiles">
<h3>Connecting Multiple CLB Tiles<a class="headerlink" href="#connecting-multiple-clb-tiles" title="Permalink to this heading">#</a></h3>
<p>Multiple CLB tiles can be strung together to enable greater CLB functionality
for applications which require complex custom logic. To do this, the outputs of
one tile (CLBx) can be used as inputs into another tile (CLBy). This can be
done in various ways:</p>
<ol class="arabic simple">
<li><p>Connect OUTLUT4 and/or OUTLUT5 of CLBx to any of the eight BOUNDARY inputs
of CLBy. This uses the CLB X-BAR and Global Signals Mux, and these should be
configured appropriately.</p></li>
<li><p>Any of the eight outputs (OUTLUT0-7) of CLBx can be connected to a GPIO.
This signal can then be brought back into the CLB peripheral using the INPUT
X-BAR. It can then be used as the BOUNDARY inputs of CLBy using the CLB X-BAR
and the Global Signals Mux.</p></li>
<li><p>Bring any of the eight outputs of CLBx to the Global Mux using the
respective replicated outputs, CLBx_OUT16 through CLBx_OUT23. Use these signals
from the global mux as inputs into another CLB tile.</p></li>
</ol>
</section>
</section>
<section id="clb-interrupts">
<h2>CLB Interrupts<a class="headerlink" href="#clb-interrupts" title="Permalink to this heading">#</a></h2>
<p>The High-Level Controller within the CLB provides a mechanism to send
interrupts to the CPU. This enables further manipulation of the registers,
counters, and data within the CLB and allows the CPU to execute actions based
on the logic within the CLB. The CLB interrupt can also be used to trigger CLA
and DMA transfers.</p>
<section id="differentiating-between-hlc-interrupts">
<h3>Differentiating Between HLC Interrupts<a class="headerlink" href="#differentiating-between-hlc-interrupts" title="Permalink to this heading">#</a></h3>
<p>Each CLB tile has access to an interrupt handler that can perform operations
when the HLC generates an interrupt. However, because all four events within
the HLC share the same interrupt handler, it is advantageous to be able to
distinguish between different event interrupts and perform different actions
accordingly. The CPU is able to do this using distinct interrupt tags generated
by the different events. For example, observe the following code excerpt:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#define COUNTER0_INT_TAG    11</span>
<span class="cp">#define COUNTER1_INT_TAG    12</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="c1">// code to instantiate any relevant device peripherals</span>
<span class="w">  </span><span class="p">...</span>
<span class="p">}</span>
<span class="n">__interrupt</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">clb1ISR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="kt">uint16_t</span><span class="w"> </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CLB_getInterruptTag</span><span class="p">(</span><span class="n">myTILE1_BASE</span><span class="p">);</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">COUNTER0_INT_TAG</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="n">GPIO_togglePin</span><span class="p">(</span><span class="n">myGPIO0</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">COUNTER1_INT_TAG</span><span class="p">)</span>
<span class="w">  </span><span class="p">{</span>
<span class="w">      </span><span class="n">GPIO_togglePin</span><span class="p">(</span><span class="n">myGPIO1</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">CLB_clearInterruptTag</span><span class="p">(</span><span class="n">myTILE1_BASE</span><span class="p">);</span>
<span class="w">  </span><span class="n">Interrupt_clearACKGroup</span><span class="p">(</span><span class="n">INTERRUPT_ACK_GROUP5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Within each HLC event’s program code, an interrupt and respective interrupt tag
can be generated using<code class="docutils literal notranslate"><span class="pre">INTR</span> <span class="pre">&lt;interrupt_tag&gt;</span></code>. The CPU is able to
distinguish between these events by grabbing the interrupt tag with the
<code class="docutils literal notranslate"><span class="pre">CLB_getInterruptTag(CLB_BASE)</span></code> function. In the excerpt code, a different
GPIO pin is toggled depending on which CLB Counter (and corresponding HLC
event) triggers the interrupt. Being able to differentiate between different
interrupts enables the CPU to perform different condition-based actions all
within the same interrupt handler.</p>
</section>
<section id="interfacing-with-the-fifo">
<h3>Interfacing with the FIFO<a class="headerlink" href="#interfacing-with-the-fifo" title="Permalink to this heading">#</a></h3>
<p>Data exchange between the HLC and the CPU occurs through a shared memory buffer
(FIFO). There are separate FIFO buffers for the PUSH and PULL operations. The
size of the PUSH and PULL FIFOs is four 32-bit words each. Exchanging data
between the CLB and CPU can be useful when needing to acquire and process the
data stored in the CLB, or when needing to dynamically overwrite the Counter
and HLC register values. The following driverlib functions allow for
interfacing with and manipulating the data within the FIFO.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Function</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CLB_clearFIFOs(CLB_BASE)</span></code></p></td>
<td><p>This function can be used to clear all data within the FIFO.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">CLB_readFIFOs(CLB_BASE,</span> <span class="pre">READ_DATA[])</span></code></p></td>
<td><p>This function can be used to read data that is pushed to the FIFO before an interrupt call. The read data is stored in an array.</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">CLB_writeFIFOs(CLB_BASE,</span> <span class="pre">WRITE_DATA[])</span></code></p></td>
<td><p>This function can be used to write data to the FIFO. This function implicitly clears the FIFO before writing to it. This written data can then be pulled into CLB and read upon an interrupt trigger.</p></td>
</tr>
</tbody>
</table>
<p>The values within the CLB can also be directly accessed without use of the
FIFO. Values within the Counter registers and HLC registers can be obtained
using the<code class="docutils literal notranslate"><span class="pre">CLB_getRegister(CLB_BASE,</span> <span class="pre">CLB_REG)</span></code> function, passing in the
respective register to be read.</p>
<p>Likewise, it is possible to move data using the R0, R1, R2, and R3 HLC
registers, which are directly accessible by the CPU. Values can be written to
all of the registers usings the<code class="docutils literal notranslate"><span class="pre">CLB_setHLCRegisters(CLB_BASE,</span> <span class="pre">R0_VAL,</span> <span class="pre">R1_VAL,</span> <span class="pre">R2_VAL,</span> <span class="pre">R3_VAL)</span></code>
function or to individual registers using the<code class="docutils literal notranslate"><span class="pre">CLB_writeInterface(CLB_BASE,</span> <span class="pre">REG_ADDR,</span> <span class="pre">REG_VAL)</span></code>.
The HLC can then use a <code class="docutils literal notranslate"><span class="pre">MOV</span></code>,<code class="docutils literal notranslate"><span class="pre">MOV_T1</span></code>, or<code class="docutils literal notranslate"><span class="pre">MOV_T2</span></code> instruction to
move the register value to another register.</p>
</section>
</section>
<section id="clb-development-tools">
<h2>CLB Development Tools<a class="headerlink" href="#clb-development-tools" title="Permalink to this heading">#</a></h2>
<p>Along with configuration capabilities, the CLB tool also provides simulation
and visualization functionality to ease in designing with CLB and to help
verify logic. These files are automatically generated by the CLB Tool and can
be imported into external programs to assist in validating the design.</p>
<section id="clb-visualization">
<h3>CLB Visualization<a class="headerlink" href="#clb-visualization" title="Permalink to this heading">#</a></h3>
<p>One of the generated files from the CLB tool is <strong>clb.dot</strong>. This file
describes the interconnections between each of the submodules within the CLB in
a graphical form. The contents of this file can be exported to any
<a class="reference external" href="http://magjac.com/graphviz-visual-editor/">Graphviz-compatible program</a> to
view the diagram. The following figure showcases an example of the CLB
submodule visualization.</p>
<p><img alt="CLB Visualization Output" src="../../_images/clb_graphviz2.png" /></p>
</section>
<section id="clb-simulation">
<h3>CLB Simulation<a class="headerlink" href="#clb-simulation" title="Permalink to this heading">#</a></h3>
<p>The CLB Tool generates a <strong>clb_sim.cpp</strong>. This file should be compiled with
other relevant CLB simulation models using a GCC compiler to generate an
executable file. Executing this file generates a <strong>CLB.vcd</strong> file which can be
loaded into any external graph viewer application to view the timing
simulations for the CLB design. The following figure is an example of a design
simulation viewed using GTKWave. The CLB’s input signals can all be adjusted to
view logic outputs for relevant test cases, enabling a comprehensive testing
and debugging process.</p>
<p><img alt="CLB Simulation Output" src="../../_images/clb_simulation.png" /></p>
</section>
</section>
<section id="debugging-clb-logic">
<h2>Debugging CLB Logic<a class="headerlink" href="#debugging-clb-logic" title="Permalink to this heading">#</a></h2>
<p>When developing logic with the Configurable Logic Block, there could be
instances where you may want to debug the logic implementation for your CLB
peripheral. Apart from using the visualization and simulation capabilities<br />
described in the CLB Development Tools section, the
points below describe other methods for debugging and troubleshooting a CLB
implementation.</p>
<section id="oscilloscope-monitoring">
<h3>Oscilloscope Monitoring<a class="headerlink" href="#oscilloscope-monitoring" title="Permalink to this heading">#</a></h3>
<p>The logic within the CLB can be monitored using an oscilloscope. To do this,
connect the desired signal to one of the OUTLUTs of the CLB tile. Bring out the
signal to an available GPIO pin as described in the CLB Tile GPIO Outputs section.
Now, it is possible to monitor the CLB signal by
probing the selected GPIO pin with the scope.</p>
</section>
<section id="clb-register-monitoring">
<h3>CLB Register Monitoring<a class="headerlink" href="#clb-register-monitoring" title="Permalink to this heading">#</a></h3>
<p>Another method of debugging the logic within the CLB peripheral is to monitor
the CLB registers. Each CLB tile has three categories of registers which hold
the logic, configurations, and data within the CLB peripheral. Refer to the
specific device’s TRM for the exact address of each of the CLB registers.</p>
<p><strong>CLB Tile Logic Config Regs</strong> (CLBx_LOGICCFG_BASE)</p>
<p>The Logic Configuration registers hold the configuration information for each
of the submodules within the CLB tile. For example, this includes information
like the combinatorial logic equations for the LUT4 and OUTLUT blocks, the
event selectors for the HLC, and the reset events for the COUNTER blocks.</p>
<p><strong>CLB Tile Logic Control Regs</strong> (CLBx_LOGICCTRL_BASE)</p>
<p>The Logic Control registers hold the information related to the inputs and
outputs of the CLB tile. For example, it holds the input selection for each CLB
tile input, the output enable selection, the GPREG registers, among other
registers. It also contains the HLC registers and the values of each of the CLB
COUNTER blocks.</p>
<p><strong>CLB Tile Data Exchange Regs</strong> (CLBx_DATAEXCH_BASE)</p>
<p>The Data Exchange registers hold the PUSH and PULL FIFO registers that are
responsible for transferring data into and out of the CLB.</p>
</section>
<section id="emulation-modes">
<h3>Emulation Modes<a class="headerlink" href="#emulation-modes" title="Permalink to this heading">#</a></h3>
<p>It is possible to make use of the C2000 device’s different emulation modes to
debug the logic within the CLB. With the various emulation modes, you can run
through the program and halt it at specific breakpoints throughout the code.
You can then choose to have the on-device peripherals continually running at
this halted point and monitor the logic and execution of the CLB. To do this,
ensure that real-time emulation mode is enabled while running a debug session.
To learn more about the different emulation modes on the device, refer to the
device’s TRM.</p>
</section>
</section>
<section id="resources">
<h2>Resources<a class="headerlink" href="#resources" title="Permalink to this heading">#</a></h2>
<section id="clb-related-collateral">
<h3>CLB Related Collateral<a class="headerlink" href="#clb-related-collateral" title="Permalink to this heading">#</a></h3>
<p><strong>Foundational</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.ti.com/video/series/C2000-configurable-logic-block.html">C2000™ Configurable Logic Block (CLB) Series</a></p></li>
<li><p><a class="reference external" href="https://e2e.ti.com/blogs_/b/industrial_strength/archive/2020/01/13/customizing-on-chip-peripherals-defies-conventional-logic">Customizing on-chip peripherals defies conventional logic</a></p></li>
<li><p><a class="reference external" href="https://www.ti.com/lit/slyp681">Enable Differentiation and win with CLB in various applications Application Report</a></p></li>
<li><p><a class="reference external" href="https://www.ti.com/video/6195168576001">Enable Differentiation with Configurable Logic in Various Automotive Applications</a></p></li>
</ul>
<p><strong>Getting Started</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="www.ti.com/lit/SPRAC77">C2000™ Position Manager PTO API Reference Guide Application Report</a></p></li>
<li><p><a class="reference external" href="http://www.ti.com/lit/SPRUIR8">CLB Tool User Guide</a></p></li>
<li><p><a class="reference external" href="https://ti.com/lit/SPRACL3">Designing With The C2000 Configurable Logic Block Application Report</a></p></li>
<li><p><a class="reference external" href="https://e2e.ti.com/support/microcontrollers/c2000-microcontrollers-group/c2000/f/c2000-microcontrollers-forum/910829/faq-how-do-i-add-sysconfig-support-pinmux-and-peripheral-initialization-to-an-existing-driverlib-project">How do I add SYSCONFIG support (Pinmux and Peripheral Initialization) to an existing driverlib project?</a></p></li>
<li><p><a class="reference external" href="https://ti.com/lit/SPRACO2">How to Migrate Custom Logic From an FPGA/CPLD to C2000 Microcontrollers Application Report</a></p></li>
</ul>
<p><strong>Expert</strong></p>
<ul class="simple">
<li><p><a class="reference external" href="https://ti.com/lit/SPRACY3">Achieve Delayed Protection for Three-Level Inverter With CLB Application Report</a></p></li>
<li><p><a class="reference external" href="https://www.ti.com/lit/SPRAD53">Diagnosing Delta-Sigma Modulator Bitstream Using C2000™ Configurable Logic Block Application Report</a></p></li>
<li><p><a class="reference external" href="https://www.ti.com/lit/SPRAD62">How to Implement Custom Serial Interfaces Using Configurable Logic Block (CLB) Application Report</a></p></li>
<li><p><a class="reference external" href="www.ti.com/lit/TIDUE74">Tamagawa T-Format Absolute-Encoder Master Interface Reference Design for C2000™ MCUs</a></p></li>
</ul>
</section>
<hr class="docutils" />
<div class="admonition-feedback admonition">
<p class="admonition-title">Feedback</p>
<p>Please provide any feedback you may have about the content within C2000 Academy to: <a class="reference external" href="mailto:c2000_academy_feedback&#37;&#52;&#48;list&#46;ti&#46;com">c2000_academy_feedback<span>&#64;</span>list<span>&#46;</span>ti<span>&#46;</span>com</a></p>
</div>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="c2000_direct_memory_access.html" title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Direct Memory Access (DMA)</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="c2000_interprocessor_communications.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">Interprocessor Communications (IPC)</p>
  </div>
  <i class="fa-solid fa-angle-right"></i>
  </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc">
<div class="toc-item">
  
<div class="tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
</div>
<nav id="bd-toc-nav" class="page-toc">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#applications-of-clb">
   Applications of CLB
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clb-tile-architecture">
   CLB Tile Architecture
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#input-lookup-table">
     4-Input Lookup Table
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#finite-state-machine">
     Finite State Machine
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#counter">
     Counter
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#output-3-input-lookup-table">
     Output 3-Input Lookup Table
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#high-level-controller">
     High-Level Controller
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#asynchronous-output-conditioning-block">
     Asynchronous Output Conditioning Block
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clb-connections">
   CLB Connections
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-input-buses">
     CLB Tile Input Buses
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-input-filtering-and-synchronization">
     CLB Tile Input Filtering and Synchronization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-software-triggering">
     CLB Tile Software Triggering
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-gpio-inputs">
     CLB Tile GPIO Inputs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-output-replication">
     CLB Tile Output Replication
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-peripheral-signal-overriding">
     CLB Tile Peripheral Signal Overriding
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-tile-gpio-outputs">
     CLB Tile GPIO Outputs
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#connecting-multiple-clb-tiles">
     Connecting Multiple CLB Tiles
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clb-interrupts">
   CLB Interrupts
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#differentiating-between-hlc-interrupts">
     Differentiating Between HLC Interrupts
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interfacing-with-the-fifo">
     Interfacing with the FIFO
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#clb-development-tools">
   CLB Development Tools
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-visualization">
     CLB Visualization
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-simulation">
     CLB Simulation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#debugging-clb-logic">
   Debugging CLB Logic
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#oscilloscope-monitoring">
     Oscilloscope Monitoring
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-register-monitoring">
     CLB Register Monitoring
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#emulation-modes">
     Emulation Modes
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#resources">
   Resources
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#clb-related-collateral">
     CLB Related Collateral
    </a>
   </li>
  </ul>
 </li>
</ul>

</nav>
</div>

<div class="toc-item">
  
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
</div>
</div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
<script async>
  async function setTheme() {
    try {
      var colorScheme = await window.parent.getTirexTheme();
      var mode = colorScheme === 'dark' ? 'dark' : 'light';
      localStorage.setItem('mode', mode);
      document.documentElement.dataset.mode = mode;
      document.documentElement.dataset.theme = colorScheme;
    } catch (error) {
      console.error('Failed to set the theme:', error);
    }
  }

  setTheme();
</script>


  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>




<script type="text/javascript">
  function extractNodeValue(url) {
    try {
      const parsedUrl = new URL(url);
      if (parsedUrl.pathname === '/tirex/explore/node') {
        const searchParams = new URLSearchParams(parsedUrl.search);
        return searchParams.get('node');
      } else {
        return null;
      }
    } catch (error) {
      console.error("Invalid URL:", error);
      return null;
    }
  }

  // Get all links on the page
  const links = document.querySelectorAll('a');

  // Get the project name and replace spaces with underscores
  var projName = "C2000 Academy";

  // Attach a click event listener to each link
  links.forEach((link) => {
    link.addEventListener('click', (event) => {
      // Prevent the default link behavior
      event.preventDefault();

      const url = link.href;
      const match = url.match(/source\/.+$/);
      const localId = match ? match[0].replace(/\.html$/, '').replace(/[\/\\\.]/g, '_').toLowerCase() : null;

      const extractedNode = extractNodeValue(url);

      if (typeof window.parent.jumpToTirexNodeOnLocal === 'function') {
        window.parent.jumpToTirexNodeOnLocal(localId, null, null, {
            throwError: true
          })
          .catch((e) => {
            if (extractedNode !== null) {
              window.parent.jumpToTirexNode(extractedNode, {
                  throwError: true
                })
                .catch((e) => {
                  window.location.href = link.href;
                })
            }
            else {
              if (url.includes("e2e.ti.com") || url.includes("dev.ti.com/gallery/view")) {
              window.open(url, "_blank")
              } else {
              window.location.href = link.href;
            }}
          })
      } else {
        window.location.href = link.href;
      }
    });
  });
</script>
  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2023, Texas Instruments.<br>

</p>

  </div>
  
</div>
  </footer>
  </body>
</html>