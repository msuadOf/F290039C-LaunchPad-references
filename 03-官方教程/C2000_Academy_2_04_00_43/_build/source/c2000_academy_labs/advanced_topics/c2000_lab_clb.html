
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Configurable Logic Block (CLB) Lab &#8212; C2000 Academy  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../_static/styles/theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/bootstrap.css?digest=796348d33e8b1d947c94" rel="stylesheet">
<link href="../../../_static/styles/pydata-sphinx-theme.css?digest=796348d33e8b1d947c94" rel="stylesheet">

  
  <link href="../../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=796348d33e8b1d947c94" rel="stylesheet">
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2">
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/local/font.css" />
    <link rel="stylesheet" type="text/css" href="https://www.ti.com/assets/fonts/font.css" />
    <link rel="stylesheet" type="text/css" href="https://www.ti.com/assets/style/resource-explorer.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94">
<link rel="preload" as="script" href="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94">

    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../../_static/togglebutton.js"></script>
    <script src="../../../_static/design-tabs.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/quizdown.js"></script>
    <script>quizdown.init({"quizdown_js": "quizdown.js", "start_on_load": true, "shuffle_answers": false, "shuffle_questions": false, "primary_color": "var(--pst-color-primary)", "secondary_color": "#DDDDDD", "text_color": "black"});</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'source/c2000_academy_labs/advanced_topics/c2000_lab_clb';</script>
    <script src="../../../_static/quizdown.js"></script>
    <link rel="canonical" href="http://127.0.0.1:8000/source/c2000_academy_labs/advanced_topics/c2000_lab_clb.html" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="eCAP Implementation Using CLB" href="c2000_lab_clb_ecap.html" />
    <link rel="prev" title="Direct Memory Access (DMA) Lab" href="c2000_lab_dma.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="docsearch:language" content="en">
  </head>
  
  
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="180" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search C2000 Academy" aria-label="Search C2000 Academy" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar"><div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
      <span class="fa-solid fa-bars"></span>
  </label>
  <div id="navbar-start">
    
  </div>

  
  <div class="col-lg-9 navbar-header-items">
    <div id="navbar-center" class="mr-auto">
      
    </div>

    <div id="navbar-end">
      
        <div class="navbar-end-item navbar-persistent--container">
          
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
        </div>
      
      
    </div>
  </div>


  
  
    <div class="navbar-persistent--mobile">
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
    </div>
  

  
  <label class="sidebar-toggle secondary-toggle" for="__secondary">
      <span class="fa-solid fa-outdent"></span>
  </label>
  

</div>
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">
        
  
  <div class="sidebar-header-items sidebar-primary__section">
    
    

    
    
  </div>

  

  
  <div class="sidebar-end-items sidebar-primary__section">
    <div class="sidebar-end-items__item">
    </div>
  </div>

  
  <div id="rtd-footer-container"></div>

      </div>
      
      <main id="main-content" class="bd-main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article"></div>
              
              
                <article class="bd-article" role="main">
                  
                  
<div id="searchbox"></div>
                  
  <section class="tex2jax_ignore mathjax_ignore" id="configurable-logic-block-clb-lab">
<h1>Configurable Logic Block (CLB) Lab<a class="headerlink" href="#configurable-logic-block-clb-lab" title="Permalink to this heading">#</a></h1>
<p>The objective of this lab is to gain familiarity with the Configurable Logic
Block (CLB) peripheral and its submodules through a guided lab example. The
scenario in this lab will consist of a pulsing ePWM signal accompanied by an
external sensor that is used to halt the ePWM. This demonstration showcases the
CLB’s ability to connect to other peripherals, perform logical operations,
override peripheral outputs, and generate interrupts to the CPU.</p>
<section id="solution">
<h2>Solution<a class="headerlink" href="#solution" title="Permalink to this heading">#</a></h2>
<p>All solutions are available
in the directory: <code class="docutils literal notranslate"><span class="pre">&lt;c2000ware_install_path&gt;/training/device/&lt;device_name&gt;</span></code>.</p>
</section>
<section id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this heading">#</a></h2>
<p>This lab scenario showcases one use case for the CLB, that being the ability to
gate the device’s other peripherals. In this hypothetical system, the sensor
acts as a fault detector. In the event that something is amiss, the sensor
signals the system to halt operation. The sensor input will rise whenever a
fault is detected, gating the ePWM pulse signal. The system will resume
operation when the fault is cleared.</p>
<p>To implement this, two external signals—corresponding to the ePWM and the
sensor input—will be routed into the CLB through the global input bus. These
signals are routed to the LUT submodule, which performs a logical AND
operation. The output of this LUT block is then fed into the OUTLUT block
corresponding to EPWM1A (in this case, OUTLUT 0). The output of EPWM1A will be
overridden with the output of the CLB tile. In addition to this, an interrupt
will be generated using the HLC submodule when the sensor input is received.
This interrupt will be used to toggle LEDs on the board, giving a visual
representation of this system. A block diagram of this implementation is shown
below.</p>
<p><img alt="Lab Block Diagram" src="../../../_images/lab_block_diagram.png" /></p>
</section>
<section id="lab-setup">
<h2>Lab Setup<a class="headerlink" href="#lab-setup" title="Permalink to this heading">#</a></h2>
<section id="hardware-setup">
<h3>Hardware Setup<a class="headerlink" href="#hardware-setup" title="Permalink to this heading">#</a></h3>
<p>You will need the following hardware for this lab:</p>
<ul class="simple">
<li><p>A C2000 controlCARD or LaunchPad with the supplied USB cable.</p></li>
<li><p>Jumper cables.</p></li>
<li><p>Oscilloscope (optional).</p></li>
</ul>
<p>Use the supplied USB cable to connect the USB Micro or USB Mini Type-B
connector to the board. Connect the USB Standard Type-A connector into your
computer USB port. You should see some LEDs light up on your board. In addition
to powering the board, a JTAG communication link is also established between
the device and Code Composer Studio. Later in the lab, the sensor GPIO pin will
be routed to either GND or 3.3V, so ensure you have a jumper cable. An
oscilloscope is optional, but will allow the ePWM output to be viewed through
GPIO0.</p>
</section>
<section id="software-setup">
<h3>Software Setup<a class="headerlink" href="#software-setup" title="Permalink to this heading">#</a></h3>
<p>The following software will need to be installed on your computer:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.ti.com/tool/CCSTUDIO-C2000">Code Composer Studio</a></p></li>
<li><p><a class="reference external" href="https://www.ti.com/tool/C2000WARE">C2000Ware</a></p></li>
</ul>
</section>
</section>
<section id="import-empty-project">
<h2>Import Empty Project<a class="headerlink" href="#import-empty-project" title="Permalink to this heading">#</a></h2>
<p>Our first task is to import an empty project to our Code Composer
Studio (CCS) workspace.
The basic instructions are as follows:</p>
<ol class="arabic simple">
<li><p>Open CCS and go to <strong>Project→Import CCS Projects</strong>. A new window should
appear. Ensure that the <strong>Select search-directory</strong> option is activated.</p></li>
<li><p>Click the <strong>Browse</strong> button and select the
<code class="docutils literal notranslate"><span class="pre">[C20000ware_Install_dir]/training/device/[device]/empty_lab</span></code>
directory.
Note that the default Windows [C20000ware_Install_dir] is <code class="docutils literal notranslate"><span class="pre">C:/ti/c2000/C2000Ware_4_xx_xx_xx</span></code>.</p></li>
<li><p>Under <strong>Discovered Projects</strong>, you should now see the
<code class="docutils literal notranslate"><span class="pre">lab_[board]_[device]</span></code> project. Select the appropriate project for either the control card or the launchpad.</p></li>
</ol>
<p><img alt="Discovered_Projects" src="../../../_images/c2000_lab_clb_start_small.png" /></p>
<ol class="arabic simple" start="4">
<li><p>Click <strong>Finish</strong> to import and copy the <code class="docutils literal notranslate"><span class="pre">lab_[board]_[device]</span></code> project
into your workspace.</p></li>
<li><p>Rename the project and source files appropriately.</p></li>
</ol>
</section>
<section id="task-1-setting-up-the-gpios">
<h2>Task 1 - Setting up the GPIOs<a class="headerlink" href="#task-1-setting-up-the-gpios" title="Permalink to this heading">#</a></h2>
<p>We will begin this lab exercise by configuring the required GPIOs within the
<code class="docutils literal notranslate"><span class="pre">c2000.syscfg</span></code> file of the project. Double-click the <code class="docutils literal notranslate"><span class="pre">c2000.syscfg</span></code> file within
the project to open the SysConfig GUI. In total, three GPIOs will be needed for
this lab, and they will serve the following functions:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>GPIO name</p></th>
<th class="head"><p>Function</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>myGPIOSensor</p></td>
<td><p>Simulates sensor for use as an input into the CLB. This GPIO will be externally tied to either GND or 3.3V to indicate the presence of a fault</p></td>
</tr>
<tr class="row-odd"><td><p>LED_EPWM_GPIO</p></td>
<td><p>GPIO tied to LED for visualizing ePWM. When this LED is on, it indicates that the ePWM is actively pulsing</p></td>
</tr>
<tr class="row-even"><td><p>LED_SENSOR_GPIO</p></td>
<td><p>GPIO tied to sensor input for visualizing sensor. When this LED is on, it indicates that the sensor is detecting a fault</p></td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">myGPIOSensor</span></code> will be configured on <code class="docutils literal notranslate"><span class="pre">GPIO27</span></code> as an input for use within the
CLB. When pulled low, the system will function normally, and when pulled high,
<code class="docutils literal notranslate"><span class="pre">myGPIOSensor</span></code> will signal a fault to the CLB. Within SysConfig, perform the
following steps:</p>
<ul class="simple">
<li><p>Add a GPIO by clicking the (+) icon next to ‘GPIO’ on the left pane</p></li>
<li><p>Set the name of the GPIO as ‘myGPIOSensor’</p></li>
<li><p>Set the GPIO as an input</p></li>
<li><p>Set the Pin Type as “Push-pull output/floating input”</p></li>
</ul>
<p>Now, we have to choose which GPIO we are configuring, in this case GPIO27. Upon
expanding the “PinMux” view we can choose the desired GPIO. Follow the steps
below:</p>
<ul class="simple">
<li><p>Click on the three dot icon at the top right of the SysConfig window</p></li>
<li><p>Select “Preferences &amp; Actions”</p></li>
<li><p>Under preferences, click on the ‘Device Pin Label’ drop down arrow
and enable “Device pin name”. This is not part of the default
SysConfig settings but allows us to see the pin name along with the
pin number</p></li>
<li><p>Within the GPIO PinMux, select GPIO27 as the desired GPIO</p></li>
</ul>
<p><img alt="SysConfig Sensor GPIO" src="../../../_images/syscfg_gpiosensor.png" /></p>
<p>To be able to use <code class="docutils literal notranslate"><span class="pre">myGPIOSensor</span></code> as a CLB input, we need to route GPIO27 as an
auxiliary signal (AUXSIG) through the global input bus. This requires using the
input crossbar (INPUTXBAR) and CLB crossbar (CLBXBAR). First, configure the
Input X-BAR to connect <code class="docutils literal notranslate"><span class="pre">GPIO27</span></code> to <code class="docutils literal notranslate"><span class="pre">INPUTXBAR1</span></code> using the steps below:</p>
<ul class="simple">
<li><p>Add Input X-BAR by clicking the (+) icon next to ‘INPUTXBAR’ on the left pane</p></li>
<li><p>Set the name of the Input X-BAR as ‘myINPUTXBAR1’</p></li>
<li><p>Select INPUTXBAR1 as the Input X-BAR instance to be used</p></li>
<li><p>Configure INPUTXBAR1 to use GPIO27</p></li>
<li><p>If desired, check the box to lock INPUTXBAR1</p></li>
</ul>
<p><img alt="SysConfig Input X-BAR" src="../../../_images/syscfg_inputxbar.png" /></p>
<p>Next, the CLB X-BAR needs to be configured to route INPUTXBAR1 as an auxiliary
signal into the CLB. Configure the CLB X-BAR to route <code class="docutils literal notranslate"><span class="pre">INPUTXBAR1</span></code> to <code class="docutils literal notranslate"><span class="pre">AUXSIG0</span></code>
using the steps below:</p>
<ul class="simple">
<li><p>Add a CLB X-BAR instance by clicking the (+) icon next to ‘CLBXBAR’ on the
left pane</p></li>
<li><p>Set the name of the CLB X-BAR as ‘myCLBXBAR0’</p></li>
<li><p>Select AUXSIG0 as the Aux Signal Input</p></li>
<li><p>Select MUX 01 as the MUX to be used for this AUXSIG0. MUX 01 is a requirement
as it provides a connection to the INPUTXBAR1 signal</p></li>
<li><p>In the MUX 1 dropdown, configure INPUTXBAR1 to be used</p></li>
</ul>
<p><img alt="SysConfig CLB X-BAR" src="../../../_images/syscfg_clbxbar.png" /></p>
<p>Now, <code class="docutils literal notranslate"><span class="pre">myGPIOSensor</span></code> (GPIO27) has been successfully configured as AUXSIG0 on the
global input bus and can be used as an input into the CLB.</p>
<p>Next, we must configure the LED GPIOs to provide a visual representation of the
system. This is done in a similar manner to a regular GPIO input. First
configure <code class="docutils literal notranslate"><span class="pre">LED_EPWM_GPIO</span></code> using the steps below:</p>
<ul class="simple">
<li><p>Add an LED by clicking the (+) icon next to ‘LED’ on the left pane</p></li>
<li><p>Set the name of this LED as ‘LED_EPWM’</p></li>
<li><p>The name of the GPIO will automatically populate to ‘LED_EPWM_GPIO’</p></li>
<li><p>Set the Pin Type as “Push-pull output/floating input”</p></li>
<li><p>Check the box to enable a write of an initial value</p></li>
<li><p>Set the initial value as “0: GPIO state is LOW”</p>
<ul>
<li><p>This will initialize ‘LED_EPWM’ to be on when the system begins running</p></li>
</ul>
</li>
<li><p>Within the GPIO PinMux, select the GPIO according to the following table</p></li>
</ul>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>LaunchPad</p></th>
<th class="head"><p>controlCARD</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F28379D</p></td>
<td><p>31</p></td>
<td><p>31</p></td>
</tr>
<tr class="row-odd"><td><p>F2838x</p></td>
<td><p>n/a</p></td>
<td><p>31</p></td>
</tr>
<tr class="row-even"><td><p>F28004x</p></td>
<td><p>23</p></td>
<td><p>31</p></td>
</tr>
<tr class="row-odd"><td><p>F28002x</p></td>
<td><p>31</p></td>
<td><p>31</p></td>
</tr>
<tr class="row-even"><td><p>F28003x</p></td>
<td><p>20</p></td>
<td><p>31</p></td>
</tr>
</tbody>
</table>
<p><img alt="SysConfig EPWM LED" src="../../../_images/syscfg_ledepwm.png" /></p>
<p>Similarly, configure <code class="docutils literal notranslate"><span class="pre">LED_SENSOR_GPIO</span></code> using the steps below:</p>
<ul class="simple">
<li><p>Add an LED by clicking the (+) icon next to ‘LED’ on the left pane</p></li>
<li><p>Set the name of this LED as ‘LED_SENSOR’</p></li>
<li><p>The name of the GPIO will automatically populate to ‘LED_SENSOR_GPIO’</p></li>
<li><p>Set the Pin Type as “Push-pull output/floating input”</p></li>
<li><p>Check the box to enable a write of an initial value</p></li>
<li><p>Set the initial value as “1: GPIO state is HIGH”</p>
<ul>
<li><p>This will initialize ‘LED_SENSOR’ to be off when the system begins running</p></li>
</ul>
</li>
<li><p>Within the GPIO PinMux, select the GPIO according to the following table</p></li>
</ul>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>LaunchPad</p></th>
<th class="head"><p>controlCARD</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F28379D</p></td>
<td><p>34</p></td>
<td><p>34</p></td>
</tr>
<tr class="row-odd"><td><p>F2838x</p></td>
<td><p>n/a</p></td>
<td><p>34</p></td>
</tr>
<tr class="row-even"><td><p>F28004x</p></td>
<td><p>34</p></td>
<td><p>34</p></td>
</tr>
<tr class="row-odd"><td><p>F28002x</p></td>
<td><p>34</p></td>
<td><p>34</p></td>
</tr>
<tr class="row-even"><td><p>F28003x</p></td>
<td><p>22</p></td>
<td><p>34</p></td>
</tr>
</tbody>
</table>
<p><img alt="SysConfig Sensor LED" src="../../../_images/syscfg_ledsensor.png" /></p>
</section>
<section id="task-2-initialize-the-epwm-module">
<h2>Task 2 - Initialize the EPWM Module<a class="headerlink" href="#task-2-initialize-the-epwm-module" title="Permalink to this heading">#</a></h2>
<p>The EPWM module will be used to represent the system and is configured to be a
2kHz PWM waveform with a 50% duty cycle on ePWM1A. For more information on the
PWM, please review the Control Peripherals module.</p>
<p>We will start by adding a PWM instance within Sysconfig by clicking on the (+)
sign next to ‘EPWM’ within the left pane of Sysconfig. Name this EPWM instance
‘myEPWM1’. Now that we have added an EPWM instance, we will configure the EPWM1
‘Timebase’ submodule as follows:</p>
<ul class="simple">
<li><p>Set <strong>High Speed Clock Divider</strong> to ‘Divide clock by 1’</p></li>
<li><p>Set <strong>Time Base Period</strong> to ‘25000’</p></li>
<li><p>Set <strong>Counter Mode</strong> to ‘Up - down - count mode’</p></li>
</ul>
<p><img alt="SysConfig EPWM Part 1" src="../../../_images/syscfg_epwm_pt1.png" /></p>
<p>The ‘Counter Compare’ submodule for EPWM1A will be as follows:</p>
<ul class="simple">
<li><p>Set <strong>Counter Compare A (CMPA)</strong> to ‘12500’</p></li>
</ul>
<p><img alt="SysConfig EPWM Part 2" src="../../../_images/syscfg_epwm_pt2.png" /></p>
<p>Now, configure the ‘Action Qualifier’ submodule for EPWM1A as follows:</p>
<ul class="simple">
<li><p>Enable Shadow Mode</p></li>
<li><p>Set <strong>Shadow Load Event</strong> to ‘Load when counter equals zero’</p></li>
<li><p>In <strong>Events to Configure for ePWMxA output</strong>, select ‘Time base counter up
equals COMPA’ and ‘Time base counter down equals COMPA’</p></li>
<li><p>Set <strong>Time base counter up equals COMPA</strong> to ‘Set output pins to High’</p></li>
<li><p>Set <strong>Time base counter down equals COMPA</strong> to ‘Set output pins to Low’</p></li>
</ul>
<p><img alt="SysConfig EPWM Part 3" src="../../../_images/syscfg_epwm_pt3.png" /></p>
<p>Lastly, we need to configure the PinMux for EPWM1A. Even though the output of
ePWM1A will be overridden by the output of the CLB, configuring the output GPIO
is good practice as it allows us to view the pure ePWM1A pulse for debugging
purposes. Follow the steps below:</p>
<ul class="simple">
<li><p>Select ‘CUSTOM’ on the EPWM1 PinMux. This allows us to select only EPWM_A as
an output</p></li>
<li><p>Configure the Pin as ‘EPWM_A’</p></li>
<li><p>Set the EPWM Peripheral to be used as ‘EPWM1’</p></li>
<li><p>Configure the ‘EPWM_A’ pin to be ‘GPIO0’</p></li>
</ul>
<p><img alt="SysConfig EPWM Part 4" src="../../../_images/syscfg_epwm_pt4.png" /></p>
</section>
<section id="task-3-setup-the-clb">
<h2>Task 3 - Setup the CLB<a class="headerlink" href="#task-3-setup-the-clb" title="Permalink to this heading">#</a></h2>
<p>To setup the CLB peripheral, we need to add a CLB instance within SysConfig. We
will need to setup this CLB instance to use the EPWM1A signal and sensor
signals as inputs. We must also attach an interrupt handler to this CLB
instance so that the HLC can issue interrupts to the CPU. Setup CLB1 by
following the steps below:</p>
<ul class="simple">
<li><p>Add a CLB by clicking the (+) icon next to ‘CLB’ on the left pane</p></li>
<li><p>Set the name of this CLB as ‘myCLB1’</p></li>
<li><p>Set the CLB Instance to be ‘CLB1’</p></li>
<li><p>Select ‘Output 0’ as the output to be overridden</p>
<ul>
<li><p>‘Output 0’ is muxed with EPWM1A in the Peripheral Signal Mux. Choosing
this option overrides the EPWM1A output with Output 0 from CLB1. Refer to
the Peripheral Signal Multiplexer Table within the device’s TRM for more
information.</p></li>
</ul>
</li>
<li><p>Select ‘Input 0’ and ‘Input 1’ as inputs into CLB1</p></li>
</ul>
<p><img alt="SysConfig CLB Peripheral" src="../../../_images/syscfg_clbperiph.png" /></p>
<p>Now we can configure the inputs into CLB1. The EPWM1A signal is directly
available on the global input bus without the need for any X-BARs. To bring in
this signal, configure Input 0 as follows:</p>
<ul class="simple">
<li><p>Set the Input type as ‘Use Global Mux’</p></li>
<li><p>Under the dropdown for Global Mux Input, select ‘EPWM1A’</p></li>
<li><p>No syncing, input syncing, or initial GPREG writes are necessary</p></li>
</ul>
<p><img alt="SysConfig CLB Input 0" src="../../../_images/syscfg_clbinput0.png" /></p>
<p>Next, we will route the sensor input into Input 1 of CLB1. Recall previously
that ‘myGPIOSensor’ was connected to AUXSIG0 through the Input X-BAR and CLB
X-BAR. Doing this allows us to select AUXSIG0 as an input into CLB1. Configure
Input 1 as follows:</p>
<ul class="simple">
<li><p>Set the Input type as ‘Use Global Mux’</p></li>
<li><p>Under the dropdown for Global Mux Input, select ‘CLB X-BAR AUXSIG0’</p></li>
<li><p>No syncing, input syncing, or initial GPREG writes are necessary</p></li>
</ul>
<p><img alt="SysConfig CLB Input 1" src="../../../_images/syscfg_clbinput1.png" /></p>
<p>Because the HLC submodule within CLB1 will be issuing interrupts to the CPU
when a fault is detected, an Interrupt Handler must be configured. Follow the
steps below to do this:</p>
<ul class="simple">
<li><p>Check the box next to ‘Register Interrupt Handler’</p></li>
<li><p>Rename the Interrupt Handler function as desired</p></li>
<li><p>Check the box next to ‘Enable Interrupt in PIE’</p></li>
</ul>
<p><img alt="SysConfig CLB Interrupt" src="../../../_images/syscfg_clbinterrupt.png" /></p>
</section>
<section id="task-4-configure-the-clb-tile">
<h2>Task 4 - Configure the CLB Tile<a class="headerlink" href="#task-4-configure-the-clb-tile" title="Permalink to this heading">#</a></h2>
<p>Now it is time to configure the CLB1 tile to perform the logic necessary to
have the sensor input gate EPWM1A. This requires configuring three kinds of
submodules within the CLB: LUT, OUTLUT, and the HLC.</p>
<p>Navigate to the ‘TILE’ peripheral within the SysConfig GUI and add a single
TILE instance. Begin the CLB tile configuration by editing LUT_1. LUT_1 will be
responsible for handling the combinatorial logic that gates the EPWM1A pulse
signal. Configure LUT_1 as follows:</p>
<ul class="simple">
<li><p>Select ‘BOUNDARY.in0’ as the input for i0. This corresponds to the PWM signal</p></li>
<li><p>Select ‘BOUNDARY.in1’ as the input for i1. This corresponds to the sensor
input</p></li>
<li><p>In the equation field, enter the following logical expression: <code class="docutils literal notranslate"><span class="pre">i0</span> <span class="pre">&amp;amp;</span> <span class="pre">!i1</span></code></p>
<ul>
<li><p>With this logic, the output of LUT_1 will be the PWM signal when i1 is
low. The output will be low when i1 is high.</p></li>
</ul>
</li>
</ul>
<p><img alt="SysConfig LUT1" src="../../../_images/syscfg_clbtile_lut1.png" /></p>
<!-- Use of LUT_2 is optional for devices with CLB Type 2 or later, as the HLC -->
<!-- is capable of being triggered by the falling edge of an input signal. -->
<p>LUT_2 will be responsible for simulating the falling edge of the sensor input.
The output of this LUT will be used as an event trigger by the HLC so that we
can toggle the LEDs when the fault is resolved. Configure LUT_2 as follows:</p>
<ul class="simple">
<li><p>Select ‘BOUNDARY.in1’ as the input for i0. This corresponds to the sensor
input</p></li>
<li><p>In the equation field, enter the following logical expression: <code class="docutils literal notranslate"><span class="pre">!i0</span></code></p></li>
</ul>
<p><img alt="SysConfig LUT2" src="../../../_images/syscfg_clbtile_lut2.png" /></p>
<p>Next, we must configure OUTLUT_0 to bring the output of LUT_1 outside of the
CLB. OUTLUT_0 corresponds to BOUNDARY.out0 of CLB1 and will override the output
of EPWM1A. Configure OUTLUT_0 as follows:</p>
<ul class="simple">
<li><p>Select ‘LUT_1.OUT’ as the input for i0. This corresponds to the output of the
LUT_1 block</p></li>
<li><p>In the equation field, enter the following logical expression: <code class="docutils literal notranslate"><span class="pre">i0</span></code></p></li>
</ul>
<p><img alt="SysConfig OUTLUT 0" src="../../../_images/syscfg_clbtile_outlut0.png" /></p>
<p>Finally, the High-Level Controller is configured with two events.</p>
<ul class="simple">
<li><p>Event 0 is triggered by the <strong>rising edge</strong> of the sensor input and will
issue an interrupt to the CPU to toggle off the EPWM LED and toggle on the
sensor LED.</p></li>
<li><p>Event 1 is triggered by the <strong>falling edge</strong> of the sensor input and will
issue an interrupt to the CPU to toggle on the EPWM LED and toggle off the
sensor LED.</p></li>
</ul>
<p>Configure the HLC as follows:</p>
<ul>
<li><p>Select ‘BOUNDARY.in1’ as the trigger condition for Event 0</p></li>
<li><p>Select ‘LUT_2.OUT’ as the trigger condition for Event 1</p>
 <!-- - Alternatively, on devices with CLB Type 2 or later, select 'BOUNDARY.in1_INVERTED' -->
</li>
<li><p>In the instruct0 field of program0, enter the following operation: <code class="docutils literal notranslate"><span class="pre">INTR</span> <span class="pre">1</span></code></p></li>
<li><p>In the instruct0 field of program1, enter the following operation: <code class="docutils literal notranslate"><span class="pre">INTR</span> <span class="pre">2</span></code></p></li>
</ul>
<p><img alt="SysConfig HLC" src="../../../_images/syscfg_clbtile_hlc.png" /></p>
</section>
<section id="task-5-setup-the-clb-isr">
<h2>Task 5 - Setup the CLB ISR<a class="headerlink" href="#task-5-setup-the-clb-isr" title="Permalink to this heading">#</a></h2>
<p>Now that we have configured the CLB and PWM modules within SysConfig, we can
switch to the application code portion of this lab. Within the project click on
the .c file under the name you chose.</p>
<p>Within the .c file, we need to write the code that will be executed everytime
there is a CLB interrupt, otherwise known as ISR (interrupt service routine).</p>
<p>Because the CLB uses multiple event interrupts, the first part of the ISR
requires grabbing the interrupt tag from the CLB. This is stored in the <code class="docutils literal notranslate"><span class="pre">tag</span></code>
variable.</p>
<p>Note: The name of the ISR function is what we defined earlier within the
SysConfig configuration for the CLB.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__interrupt</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">INT_myCLB1_ISR</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Get interrupt tag upon HLC interrupt</span>
<span class="w">    </span><span class="n">tag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CLB_getInterruptTag</span><span class="p">(</span><span class="n">myCLB1_BASE</span><span class="p">);</span>
</pre></div>
</div>
<p>The next portion of the ISR function involves deciphering the interrupt tag and
toggling the LEDs depending on what tag is received by the CPU. If <code class="docutils literal notranslate"><span class="pre">tag</span></code>
matches the interrupt tag sent by Event 0 (rising edge of sensor input), the
CPU will turn off the EPWM LED and turn on the sensor LED. Instead, if <code class="docutils literal notranslate"><span class="pre">tag</span></code>
matches the interrupt tag sent by Event 1 (falling edge of sensor input), the
CPU will turn on the EPWM LED and turn off the sensor LED.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">   </span><span class="c1">// Turn off EPWM LED and turn on SENSOR LED</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENSOR_HIGH_INT_TAG</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">     </span><span class="n">GPIO_writePin</span><span class="p">(</span><span class="n">LED_EPWM_GPIO</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">     </span><span class="n">GPIO_writePin</span><span class="p">(</span><span class="n">LED_SENSOR_GPIO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="c1">// Turn on EPWM LED and turn off SENSOR LED</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">tag</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">SENSOR_LOW_INT_TAG</span><span class="p">)</span>
<span class="w">   </span><span class="p">{</span>
<span class="w">     </span><span class="n">GPIO_writePin</span><span class="p">(</span><span class="n">LED_EPWM_GPIO</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">     </span><span class="n">GPIO_writePin</span><span class="p">(</span><span class="n">LED_SENSOR_GPIO</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">   </span><span class="p">}</span>
</pre></div>
</div>
<p>Lastly, we must acknowledge the PIE group as well as clear the interrupt status
flag so that we can continue to service interrupts in the future.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="n">CLB_clearInterruptTag</span><span class="p">(</span><span class="n">myCLB1_BASE</span><span class="p">);</span>
<span class="w">    </span><span class="n">Interrupt_clearACKGroup</span><span class="p">(</span><span class="n">INTERRUPT_ACK_GROUP5</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
<section id="task-6-setup-the-c-file">
<h2>Task 6 - Setup the .c file<a class="headerlink" href="#task-6-setup-the-c-file" title="Permalink to this heading">#</a></h2>
<p>The last thing we have to do is define any variables we are using throughout
the project and setup the content within the main() function, which includes
device initialization.</p>
<p>We begin by including the basic necessary libraries <code class="docutils literal notranslate"><span class="pre">driverlib.h</span></code> and <code class="docutils literal notranslate"><span class="pre">device.</span> <span class="pre">h</span></code>. Next, include the SysConfig-generated header file <code class="docutils literal notranslate"><span class="pre">board.h</span></code>. This should
already be included by default. Lastly, include the <code class="docutils literal notranslate"><span class="pre">clb_config.h</span></code> and <code class="docutils literal notranslate"><span class="pre">clb.h</span></code>
libraries, which are required for proper CLB function. These two CLB libraries
are included by default if the <code class="docutils literal notranslate"><span class="pre">clb_empty</span></code> project was imported.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Included Files</span>
<span class="c1">//</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;driverlib.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;device.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;board.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clb_config.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;clb.h&quot;</span>
</pre></div>
</div>
<p>Then we define the two interrupt tags, <code class="docutils literal notranslate"><span class="pre">SENSOR_HIGH_INT_TAG</span></code> and
<code class="docutils literal notranslate"><span class="pre">SENSOR_LOW_INT_TAG</span></code>, which will be issued by the HLC.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">//</span>
<span class="c1">// Global variables and definitions</span>
<span class="c1">//</span>
<span class="cp">#define     SENSOR_HIGH_INT_TAG 1</span>
<span class="cp">#define     SENSOR_LOW_INT_TAG  2</span>
<span class="kt">uint16_t</span><span class="w">    </span><span class="n">tag</span><span class="p">;</span>
</pre></div>
</div>
<p>Lastly, we define the contents within main() which includes device
initialization and peripheral setup:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// CPU Initialization</span>
<span class="w">    </span><span class="n">Device_init</span><span class="p">();</span>
<span class="w">    </span><span class="n">Device_initGPIO</span><span class="p">();</span>
<span class="w">    </span><span class="n">Interrupt_initModule</span><span class="p">();</span>
<span class="w">    </span><span class="n">Interrupt_initVectorTable</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Configure the GPIOs/XBARs/PWM/CLB/LEDs through</span>
<span class="w">    </span><span class="c1">// SysConfig-generated function found within board.c</span>
<span class="w">    </span><span class="n">Board_init</span><span class="p">();</span>
<span class="w">    </span><span class="c1">// Initialize and enable the CLB1 tile</span>
<span class="w">    </span><span class="n">initTILE1</span><span class="p">(</span><span class="n">myCLB1_BASE</span><span class="p">);</span>
<span class="w">    </span><span class="n">CLB_enableCLB</span><span class="p">(</span><span class="n">myCLB1_BASE</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// Enable global interrupts and real-time debug</span>
<span class="w">    </span><span class="n">EINT</span><span class="p">;</span>
<span class="w">    </span><span class="n">ERTM</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Main Loop</span>
<span class="w">    </span><span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">asm</span><span class="p">(</span><span class="s">&quot; NOP&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This concludes the coding portion of this lab.</p>
</section>
<section id="running-the-lab">
<h2>Running the Lab<a class="headerlink" href="#running-the-lab" title="Permalink to this heading">#</a></h2>
<section id="build-and-run-interactive-debug-session">
<h3>Build and Run Interactive Debug Session<a class="headerlink" href="#build-and-run-interactive-debug-session" title="Permalink to this heading">#</a></h3>
<ul class="simple">
<li><p>Ensure that the USB cable from your LaunchPad or controlCARD is connected to
your computer. If you have a LaunchPad, right click on your project in the
project explorer pane and click <strong>Properties→Build→C2000
Compiler→Predefined Symbols</strong>, add <code class="docutils literal notranslate"><span class="pre">_LAUNCHXL_F28XXXXX</span></code> as a predefined
symbol according to your <code class="docutils literal notranslate"><span class="pre">device.h</span></code> header file. The <code class="docutils literal notranslate"><span class="pre">device.h</span></code> file can be
found in the <code class="docutils literal notranslate"><span class="pre">&lt;projectroot&gt;/device/</span></code> directory.</p></li>
<li><p>Under the <strong>Build</strong> button, activate the <strong>CPU1_RAM</strong> build configuration.
Use the <strong>CPU1_LAUNCHXL_RAM</strong> build configuration if it is available and if
you are using a LaunchPad. Build the program and fix any compilation errors.</p></li>
<li><p>Create a new debug configuration. Set the target configuration to be
<code class="docutils literal notranslate"><span class="pre">${workspace_loc:/&lt;projectroot&gt;/targetConfigs/TMS320F28XXXXX_LaunchPad.ccxml}</span></code>
if using a LaunchPad, else, use
<code class="docutils literal notranslate"><span class="pre">${workspace_loc:/&lt;projectroot&gt;/targetConfigs/TMS320F28XXXXX.ccxml}</span></code>.
Select the current project to be loaded to <strong>CPU1</strong>. Press <strong>Apply</strong> and
close the window.</p></li>
<li><p>Prior to running the lab, ensure that a jumper cable is connected between the
GPIO27 pin and a GND header.
- Refer to the following table for the location of GPIO27 on your device</p></li>
</ul>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>LaunchPad</p></th>
<th class="head"><p>controlCARD</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F28379D</p></td>
<td><p>J6-52</p></td>
<td><p>Header-81</p></td>
</tr>
<tr class="row-odd"><td><p>F2838x</p></td>
<td><p>n/a</p></td>
<td><p>Header-81</p></td>
</tr>
<tr class="row-even"><td><p>F28004x</p></td>
<td><p>J6-59</p></td>
<td><p>Header-81</p></td>
</tr>
<tr class="row-odd"><td><p>F28002x</p></td>
<td><p>J2-11</p></td>
<td><p>Header-81</p></td>
</tr>
<tr class="row-even"><td><p>F28003x</p></td>
<td><p>J5-59</p></td>
<td><p>Header-81</p></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><p>Now we will start the debug session. Under the debug button, start the debug
session using the new configuration. You should now see the debugging
session open up and the debugger should have reached <code class="docutils literal notranslate"><span class="pre">main()</span></code>.</p></li>
<li><p>Click the <strong>Resume</strong> button.</p></li>
</ul>
</section>
<section id="observe-the-lab">
<h3>Observe the Lab<a class="headerlink" href="#observe-the-lab" title="Permalink to this heading">#</a></h3>
<p>For this lab, there are three methods to monitor the activity of the CLB and
ePWM. Observing the system using a combination of all three methods is
recommended to develop the best understanding from this lab.</p>
<p><strong>Method 1:</strong> Monitor the PWM waveform output through GPIO0 using an oscilloscope.</p>
<p>Refer to the following table for the location of GPIO0 on your device.</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p>Device</p></th>
<th class="head"><p>LaunchPad</p></th>
<th class="head"><p>controlCARD</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>F28379D</p></td>
<td><p>J4-40</p></td>
<td><p>Header-49</p></td>
</tr>
<tr class="row-odd"><td><p>F2838x</p></td>
<td><p>n/a</p></td>
<td><p>Header-49</p></td>
</tr>
<tr class="row-even"><td><p>F28004x</p></td>
<td><p>J8-80</p></td>
<td><p>Header-49</p></td>
</tr>
<tr class="row-odd"><td><p>F28002x</p></td>
<td><p>J4-40</p></td>
<td><p>Header-49</p></td>
</tr>
<tr class="row-even"><td><p>F28003x</p></td>
<td><p>J4-40</p></td>
<td><p>Header-49</p></td>
</tr>
</tbody>
</table>
<p><strong>Method 2:</strong> Monitor the configured LEDs on the LaunchPad/controlCARD.</p>
<p><strong>Method 3:</strong> Monitor the ‘tag’ variable under the ‘Expressions’ tab within CCS.</p>
<ul class="simple">
<li><p>When running the lab, observe the initial state of the system. A PWM waveform
should be present on the oscilloscope, the EPWM LED should be on, the sensor
LED should be off, and the <code class="docutils literal notranslate"><span class="pre">tag</span></code> variable displays a 2.</p></li>
</ul>
<p><img alt="EPWM Running" src="../../../_images/EPWMon.png" /></p>
<ul class="simple">
<li><p>Now that the initial system has been verified, simulate the situation where
the sensor detects a fault. To do this, remove the end of the jumper cable
attached to the GND pin and attach it to a 3.3V header. This will simulate
the rising edge of the sensor input.</p></li>
<li><p>Observe what happens to the system when this is done. The oscilloscope screen
should now display a flat line at 0V, as opposed to a waveform. On the board,
the EPWM LED should now be turned off and the sensor LED should be on. The
<code class="docutils literal notranslate"><span class="pre">tag</span></code> variable in the Expressions tab should display a 1, indicating that the
rising edge of the sensor input was received. These observations successfully
showcase that the CLB was able to gate the ePWM signal using the sensor input.</p></li>
</ul>
<p><img alt="EPWM Off" src="../../../_images/EPWMoff.png" /></p>
<ul class="simple">
<li><p>Now, simulate the scenario where the fault has been resolved and the PWM
pulse should resume functioning. To do this, disconnect the jumper cable from 3.
3V and return it to GND. The system should begin running as initially. That is,
a PWM signal should be present on the oscilloscope screen, the EPWM LED should
be on, and the <code class="docutils literal notranslate"><span class="pre">tag</span></code> variable should display 2, indicating that the falling
edge of the sensor input was received.</p></li>
</ul>
<p>Terminate the debug session and close the project. This concludes the lab
assignment.</p>
</section>
</section>
<section id="additional-practice">
<h2>Additional Practice<a class="headerlink" href="#additional-practice" title="Permalink to this heading">#</a></h2>
<div class="admonition-try-it-yourself admonition">
<p class="admonition-title">Try It Yourself!</p>
<p>Test your CLB knowledge by expanding on the scenario described in this lab.
Instead of having the sensor input gate the ePWM signal only when the sensor
is high, adjust the logic within the CLB so that the ePWM shuts off completely
upon receiving the sensor input. Ensure that the ePWM does not resume pulsing
when the sensor input goes low.</p>
</div>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Hint 1<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">This new scenario makes use of a Finite-State Machine (FSM) submodule in
addition to the LUT4 submodule.</p>
</div>
</details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Hint 2<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Configure the FSM as a 2-state 1-input finite-state machine. If needed, create
a state table and use a Karnuagh Map to assist in creating the state equations.
A state transition occurs only when the ePWM is running and the sensor input
rises. Any other combination of state and input leave the pulse unaffected.</p>
</div>
</details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Hint 3<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">Reconfigure input1 of the LUT4 to use the output state of the FSM instead of
the CLB’s BOUNDARY input.</p>
</div>
</details><details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Solution<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">To correctly implement this new CLB scenario, it will be helpful to make use of
the finite-state machine (FSM) submodule. With the FSM block, we can create
state-based logic to simulate the sensor input shutting down the system.</p>
<p class="sd-card-text">The first step is to define the logic that will be used by the FSM to implement
this scenario. This new implementation only requires two states (a pulsing
state and a shutdown state) and a single sensor input. The FSM will be modeled
after the following state diagram:</p>
<p class="sd-card-text"><img alt="FSM Block Diagram" src="../../../_images/FSM.png" /></p>
<p class="sd-card-text">To begin, construct a truth table describing the logic and state transitions
that result from the sensor input. The values of the states will be 0 and 1
corresponding to “ePWM on” and “ePWM off”, respectively. To simplify the logic,
the FSM output will correspond directly with the value of the current state.
This means that the FSM will function similarly to the LUT in that a state
output of 0 will correspond to a pulsing EPWM and a state output of 1 will
correspond to a gated PWM signal. The finished truth table should look similar
to this:</p>
<table class="table">
<thead>
<tr class="row-odd"><th class="head"><p class="sd-card-text">Current State</p></th>
<th class="head"><p class="sd-card-text">Input</p></th>
<th class="head"><p class="sd-card-text">Next State</p></th>
<th class="head"><p class="sd-card-text">Output</p></th>
</tr>
</thead>
</table>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>0         |   0   |     0      |   0
0         |   1   |     1      |   0
0         |   0   |     1      |   1
0         |   1   |     1      |   1
</pre></div>
</div>
<p class="sd-card-text">The state and output equations can be derived either through analysis or with a
K-map. Notice that the Next State represents a single OR operation on the
Current State and Input fields. The Output equation corresponds directly with
the Current State field. Thus, the necessary logic equations are:</p>
<p class="sd-card-text"><code class="docutils literal notranslate"><span class="pre">Next</span> <span class="pre">State</span> <span class="pre">=</span> <span class="pre">(Current</span> <span class="pre">State)</span> <span class="pre">|</span> <span class="pre">(Input)</span></code></p>
<p class="sd-card-text"><code class="docutils literal notranslate"><span class="pre">Output</span> <span class="pre">=</span> <span class="pre">Current</span> <span class="pre">State</span></code></p>
<p class="sd-card-text">Now, configure FSM_0 with the derived logic equations.</p>
<ul class="simple">
<li><p class="sd-card-text">Select ‘BOUNDARY.in1’ as the input for e0. This corresponds to the sensor
input</p></li>
<li><p class="sd-card-text">In the s0 state equation field (eqn_s0), enter the following logical
expression: <code class="docutils literal notranslate"><span class="pre">s0</span> <span class="pre">|</span> <span class="pre">e0</span></code></p></li>
<li><p class="sd-card-text">In the output equation field (eqn_out), enter the following logical
expression: <code class="docutils literal notranslate"><span class="pre">s0</span></code></p></li>
</ul>
<p class="sd-card-text"><img alt="SysConfig FSM" src="../../../_images/syscfg_fsm.png" /></p>
<p class="sd-card-text">Now, that the FSM has been configured, reconfigure LUT_1 to use this signal as
opposed to the sensor input signal. In LUT_1, do the following:</p>
<ul class="simple">
<li><p class="sd-card-text">Select ‘FSM_0.OUT’ as the input for i1.</p></li>
</ul>
<p class="sd-card-text"><img alt="SysConfig New LUT_1" src="../../../_images/syscfg_clbtile_new_lut1.png" /></p>
<p class="sd-card-text">LUT_2 and HLC event 2 were used to represent the falling edge of the sensor
input. Since the falling edge is no longer being considered, reset the
configuration for LUT_2 and HLC event 2. Also, remove the logic within the
interrupt handler that corresponds to the falling edge of the sensor input.</p>
<p class="sd-card-text">Like in the original implementation, setup a debug session in CCS and observe
the lab on your device. Notice that when GPIO27 is brought high, the PWM pulse
remains off, even when the sensor signal falls.</p>
</div>
</details></section>
<section id="full-solution">
<h2>Full Solution<a class="headerlink" href="#full-solution" title="Permalink to this heading">#</a></h2>
<p>The full solution to this lab exercise is included as part of the C2000Ware
SDK. Import the project from
<code class="docutils literal notranslate"><span class="pre">&lt;c2000ware_install_path&gt;/training/device/&lt;device_name&gt;/advance_topics/lab_clb</span></code>.</p>
<hr class="docutils" />
<div class="admonition-feedback admonition">
<p class="admonition-title">Feedback</p>
<p>Please provide any feedback you may have about the content within C2000 Academy to: <a class="reference external" href="mailto:c2000_academy_feedback&#37;&#52;&#48;list&#46;ti&#46;com">c2000_academy_feedback<span>&#64;</span>list<span>&#46;</span>ti<span>&#46;</span>com</a></p>
</div>
</section>
</section>


                </article>
              
              
              
                <footer class="bd-footer-article">
                  <!-- Previous / next buttons -->
<div class='prev-next-area'>
  <a class='left-prev' id="prev-link" href="c2000_lab_dma.html" title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
          <p class="prev-next-subtitle">previous</p>
          <p class="prev-next-title">Direct Memory Access (DMA) Lab</p>
      </div>
  </a>
  <a class='right-next' id="next-link" href="c2000_lab_clb_ecap.html" title="next page">
  <div class="prev-next-info">
      <p class="prev-next-subtitle">next</p>
      <p class="prev-next-title">eCAP Implementation Using CLB</p>
  </div>
  <i class="fa-solid fa-angle-right"></i>
  </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc">
<div class="toc-item">
  
<div class="tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
</div>
<nav id="bd-toc-nav" class="page-toc">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#solution">
   Solution
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   Introduction
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#lab-setup">
   Lab Setup
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#hardware-setup">
     Hardware Setup
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#software-setup">
     Software Setup
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#import-empty-project">
   Import Empty Project
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-1-setting-up-the-gpios">
   Task 1 - Setting up the GPIOs
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-2-initialize-the-epwm-module">
   Task 2 - Initialize the EPWM Module
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-3-setup-the-clb">
   Task 3 - Setup the CLB
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-4-configure-the-clb-tile">
   Task 4 - Configure the CLB Tile
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-5-setup-the-clb-isr">
   Task 5 - Setup the CLB ISR
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#task-6-setup-the-c-file">
   Task 6 - Setup the .c file
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#running-the-lab">
   Running the Lab
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#build-and-run-interactive-debug-session">
     Build and Run Interactive Debug Session
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#observe-the-lab">
     Observe the Lab
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#additional-practice">
   Additional Practice
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#full-solution">
   Full Solution
  </a>
 </li>
</ul>

</nav>
</div>

<div class="toc-item">
  
<button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-toggle="tooltip">
  <i class="fa-solid fa-magnifying-glass"></i>
</button>
</div>
</div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
<script async>
  async function setTheme() {
    try {
      var colorScheme = await window.parent.getTirexTheme();
      var mode = colorScheme === 'dark' ? 'dark' : 'light';
      localStorage.setItem('mode', mode);
      document.documentElement.dataset.mode = mode;
      document.documentElement.dataset.theme = colorScheme;
    } catch (error) {
      console.error('Failed to set the theme:', error);
    }
  }

  setTheme();
</script>


  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../_static/scripts/bootstrap.js?digest=796348d33e8b1d947c94"></script>
<script src="../../../_static/scripts/pydata-sphinx-theme.js?digest=796348d33e8b1d947c94"></script>




<script type="text/javascript">
  function extractNodeValue(url) {
    try {
      const parsedUrl = new URL(url);
      if (parsedUrl.pathname === '/tirex/explore/node') {
        const searchParams = new URLSearchParams(parsedUrl.search);
        return searchParams.get('node');
      } else {
        return null;
      }
    } catch (error) {
      console.error("Invalid URL:", error);
      return null;
    }
  }

  // Get all links on the page
  const links = document.querySelectorAll('a');

  // Get the project name and replace spaces with underscores
  var projName = "C2000 Academy";

  // Attach a click event listener to each link
  links.forEach((link) => {
    link.addEventListener('click', (event) => {
      // Prevent the default link behavior
      event.preventDefault();

      const url = link.href;
      const match = url.match(/source\/.+$/);
      const localId = match ? match[0].replace(/\.html$/, '').replace(/[\/\\\.]/g, '_').toLowerCase() : null;

      const extractedNode = extractNodeValue(url);

      if (typeof window.parent.jumpToTirexNodeOnLocal === 'function') {
        window.parent.jumpToTirexNodeOnLocal(localId, null, null, {
            throwError: true
          })
          .catch((e) => {
            if (extractedNode !== null) {
              window.parent.jumpToTirexNode(extractedNode, {
                  throwError: true
                })
                .catch((e) => {
                  window.location.href = link.href;
                })
            }
            else {
              if (url.includes("e2e.ti.com") || url.includes("dev.ti.com/gallery/view")) {
              window.open(url, "_blank")
              } else {
              window.location.href = link.href;
            }}
          })
      } else {
        window.location.href = link.href;
      }
    });
  });
</script>
  <footer class="bd-footer"><div class="bd-footer__inner container">
  
  <div class="footer-item">
    
<p class="copyright">

    &copy; Copyright 2023, Texas Instruments.<br>

</p>

  </div>
  
</div>
  </footer>
  </body>
</html>